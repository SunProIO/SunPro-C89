<?xml version="1.0" encoding="UTF-8"?>
<doc xmlns:aid="http://ns.adobe.com/AdobeInDesign/4.0/"><title aid:pstyle="h1">第3章　声質変換のための様々なモジュールの実装</title><?dtp level="1" section="第3章　声質変換のための様々なモジュールの実装"?>
<p>この章では、声質変換のために必要となる様々なモジュールの実装と簡単な解説を行う。</p>
<title aid:pstyle="h2">3.1　STFファイルの読み書き</title><?dtp level="2" section="3.1　STFファイルの読み書き"?>
<p>声質変換を行うためには、まずTANDEM-STRAIGHTで抽出された特徴量をPythonで扱える形式に変換しなければならない。しかし、PythonからTANDEM-STRAIGHTをライブラリとして呼び出し、結果を受け取るのはかなり煩雑なので、TANDEM-STRAIGHTの音声データから抽出した特徴量をSTFファイルという独自形式で保存する機能を利用する。</p>
<p>まず、音声データをSTFファイルに変換するには、配布されているTANDEM-STRAIGHTライブラリ内のGenerateSTFという実行ファイルを利用できる。そうして得られるSTFファイルを、Pythonで扱いやすいようデータを読み込んで、numpyの配列に変換するようなライブラリを実装する。</p>
<p>STFファイルについての具体的な仕様は配布されているライブラリ内のドキュメントに詳しく記載されているが、簡単に説明すると、1つのSTFファイルは複数のチャンクからなり、それぞれのチャンクは格納しているデータの種類を表すチャンク名、チャンクサイズ、そしてデータから構成されている。チャンクのうち、特徴量に直接関係のない制御用のものは以下の3つである。</p>
<ul>
<li aid:pstyle="ul-item">STFT: エンディアンやサンプリング周波数などがヘッダ情報を表すチャンク</li>
<li aid:pstyle="ul-item">CHKL: そのSTFファイルに含まれるチャンクのリストを表すチャンク</li>
<li aid:pstyle="ul-item">NXFL: 複数ファイルに亘る場合に用いられるチャンク</li>
</ul>
<p>ただし、GenerateSTFで得られるSTFファイルではNXFLチャンクは用いられないので、STFTとCHKLのみに対して処理を行えばよい。また、特徴量を表すチャンクはいくつかあるが、以下の3つのチャンクが存在していれば合成が可能なので、これら以外は無視してもよい。</p>
<ul>
<li aid:pstyle="ul-item">F0: 音声データの基本周波数</li>
<li aid:pstyle="ul-item">SPEC: 音声データのスペクトル包絡</li>
<li aid:pstyle="ul-item">APSG: 音声データの非周期成分をシグモイド関数のパラメータとして表したもの</li>
</ul>
<p>これをPythonで実装したのが、以下のソースコードである。</p>
<codelist>
<caption>リスト3.1　stf.py</caption>
<pre><span type='lineno'> 1: </span>#!/usr/bin/env python
<span type='lineno'> 2: </span>
<span type='lineno'> 3: </span>import numpy
<span type='lineno'> 4: </span>import os
<span type='lineno'> 5: </span>import struct
<span type='lineno'> 6: </span>import sys
<span type='lineno'> 7: </span>
<span type='lineno'> 8: </span>class STF:
<span type='lineno'> 9: </span>    def __init__(self, filename = None):
<span type='lineno'>10: </span>        self.endian = '&gt;'
<span type='lineno'>11: </span>        self.chunks = ['APSG', 'F0  ', 'SPEC']
<span type='lineno'>12: </span>
<span type='lineno'>13: </span>    def loadfile(self, filename):
<span type='lineno'>14: </span>        with open(filename, 'rb') as stf_file:
<span type='lineno'>15: </span>            self.load(stf_file)
<span type='lineno'>16: </span>
<span type='lineno'>17: </span>    def load(self, stf_file):
<span type='lineno'>18: </span>        filesize = os.fstat(stf_file.fileno()).st_size
<span type='lineno'>19: </span>
<span type='lineno'>20: </span>        while stf_file.tell() &lt; filesize:
<span type='lineno'>21: </span>            chunk = stf_file.read(4)
<span type='lineno'>22: </span>
<span type='lineno'>23: </span>            if chunk == 'STRT':
<span type='lineno'>24: </span>                if stf_file.read(2) == '\xff\xfe':
<span type='lineno'>25: </span>                    self.endian = '&lt;'
<span type='lineno'>26: </span>                chunk_size, self.version, self.channel, self.frequency \
<span type='lineno'>27: </span>                    = struct.unpack(self.endian + 'IHHI', stf_file.read(12))
<span type='lineno'>28: </span>            else:
<span type='lineno'>29: </span>                chunk_size, = struct.unpack(self.endian + 'I', stf_file.read(4))
<span type='lineno'>30: </span>
<span type='lineno'>31: </span>                if chunk == 'CHKL' or chunk == 'NXFL':
<span type='lineno'>32: </span>                    data = stf_file.read(chunk_size)
<span type='lineno'>33: </span>                    if chunk == 'CHKL':
<span type='lineno'>34: </span>                        self.chunks += [data[i: i + 4] \
<span type='lineno'>35: </span>                            for i in range(0, chunk_size, 4) \
<span type='lineno'>36: </span>                            if data[i: i + 4] not in self.chunks]
<span type='lineno'>37: </span>                else:
<span type='lineno'>38: </span>                    self.shift_length, frame_count, argument, \
<span type='lineno'>39: </span>                    self.bit_size, self.weight, data_size \
<span type='lineno'>40: </span>                        = struct.unpack(self.endian + 'dIIHdI', stf_file.read(30))
<span type='lineno'>41: </span>                    data = stf_file.read(data_size)
<span type='lineno'>42: </span>
<span type='lineno'>43: </span>                    element = data_size / (self.bit_size / 8)
<span type='lineno'>44: </span>                    matrix = numpy.fromstring(data, count = element)
<span type='lineno'>45: </span>
<span type='lineno'>46: </span>                    for c in self.chunks:
<span type='lineno'>47: </span>                        if chunk == c:
<span type='lineno'>48: </span>                            if element / frame_count == 1:
<span type='lineno'>49: </span>                                self.__dict__[c.strip()] = matrix
<span type='lineno'>50: </span>                            else:
<span type='lineno'>51: </span>                                self.__dict__[c.strip()] \
<span type='lineno'>52: </span>                                    = matrix.reshape( \
<span type='lineno'>53: </span>                                        (frame_count, element / frame_count))
<span type='lineno'>54: </span>                            break
<span type='lineno'>55: </span>
<span type='lineno'>56: </span>        for c in self.chunks:
<span type='lineno'>57: </span>            if c.strip() not in self.__dict__:
<span type='lineno'>58: </span>                self.__dict__[c.strip()] = None
<span type='lineno'>59: </span>
<span type='lineno'>60: </span>    def savefile(self, filename):
<span type='lineno'>61: </span>        with open(filename, 'wb') as stf_file:
<span type='lineno'>62: </span>            self.save(stf_file)
<span type='lineno'>63: </span>
<span type='lineno'>64: </span>    def save(self, stf_file):
<span type='lineno'>65: </span>        stf_file.write('STRT')
<span type='lineno'>66: </span>        if self.endian == '&gt;':
<span type='lineno'>67: </span>            stf_file.write('\xfe\xff')
<span type='lineno'>68: </span>        elif self.endian == '&lt;':
<span type='lineno'>69: </span>            stf_file.write('\xff\xfe')
<span type='lineno'>70: </span>        stf_file.write(struct.pack(self.endian + 'IHHI', 8, \
<span type='lineno'>71: </span>            self.version, self.channel, self.frequency))
<span type='lineno'>72: </span>
<span type='lineno'>73: </span>        stf_file.write('CHKL')
<span type='lineno'>74: </span>        stf_file.write(struct.pack(self.endian + 'I', \
<span type='lineno'>75: </span>            len(''.join(self.chunks))) + ''.join(self.chunks))
<span type='lineno'>76: </span>
<span type='lineno'>77: </span>        for c in self.chunks:
<span type='lineno'>78: </span>            if self.__dict__[c.strip()] is None:
<span type='lineno'>79: </span>                continue
<span type='lineno'>80: </span>
<span type='lineno'>81: </span>            matrix = self.__dict__[c.strip()]
<span type='lineno'>82: </span>            if len(matrix.shape) == 1:
<span type='lineno'>83: </span>                argument = 1
<span type='lineno'>84: </span>            else:
<span type='lineno'>85: </span>                argument = matrix.shape[1]
<span type='lineno'>86: </span>            data_size = matrix.shape[0] * argument * 8
<span type='lineno'>87: </span>
<span type='lineno'>88: </span>            header = struct.pack(self.endian + 'dIIHdI', self.shift_length, \
<span type='lineno'>89: </span>                matrix.shape[0], argument, self.bit_size, self.weight, data_size)
<span type='lineno'>90: </span>            stf_file.write(c + \
<span type='lineno'>91: </span>                struct.pack(self.endian + 'I', len(header) + data_size) + header)
<span type='lineno'>92: </span>
<span type='lineno'>93: </span>            for i in xrange(matrix.shape[0]):
<span type='lineno'>94: </span>                if argument == 1:
<span type='lineno'>95: </span>                    stf_file.write(struct.pack(self.endian + 'd', matrix[i]))
<span type='lineno'>96: </span>                else:
<span type='lineno'>97: </span>                    for j in xrange(matrix.shape[1]):
<span type='lineno'>98: </span>                        stf_file.write(struct.pack(self.endian + 'd', \
<span type='lineno'>99: </span>                                                            matrix[i, j]))
<span type='lineno'>100: </span>
<span type='lineno'>101: </span>if __name__ == '__main__':
<span type='lineno'>102: </span>    if len(sys.argv) &lt; 2:
<span type='lineno'>103: </span>        print 'Usage: %s &lt;stf_file&gt;' % sys.argv[0]
<span type='lineno'>104: </span>        sys.exit()
<span type='lineno'>105: </span>
<span type='lineno'>106: </span>    stf = STF()
<span type='lineno'>107: </span>    stf.loadfile(sys.argv[1])
<span type='lineno'>108: </span>    print stf.F0
</pre></codelist>
<p>基本的に、structモジュールを用いてデータの読み込み・書き込みを行っている。STFクラスのself.chunksに含まれているチャンクは、インスタンス変数としてnumpyの配列に変換されるようになっている。</p>
<title aid:pstyle="h2">3.2　MFCCの抽出</title><?dtp level="2" section="3.2　MFCCの抽出"?>
<p>次に、STFファイルから読み込んだスペクトル包絡からMFCCを抽出するライブラリを実装する。また、声質変換後の音声合成のために、MFCCからスペクトル包絡を復元する機能も実装する。なお、実装にあたっては、「人工知能に関する断創録<span type='bibref' idref='mfcc-aidiary'>[4]</span>」を参考にした。</p>
<p>まず、周波数をMFCCの算出に用いるメル尺度という音高の知覚的尺度に変換する関数と、その逆の処理をする関数を用意する。hz2melによって周波数をメル尺度に、mel2hzによってメル尺度を周波数に変換する。</p>
<list type='emlist'><caption aid:pstyle='emlist-title'>周波数とメル尺度の変換</caption>
<pre>    def hz2mel(self, f):
        return 1127.01048 * numpy.log(f / 700.0 + 1.0)

    def mel2hz(self, m):
        return 700.0 * (numpy.exp(m / 1127.01048) - 1.0)
</pre></list>
<p>次に、メルフィルタバンクを計算する。これは、メル尺度上で等間隔にならぶバンドパスフィルタを並べたものであり、このフィルタをスペクトル包絡に適用することで人間が知覚しにくい領域の重みが小さくなる。</p>
<list type='emlist'><caption aid:pstyle='emlist-title'>メルフィルタバンクの導出</caption>
<pre>    def melFilterBank(self):
        # サンプリング周波数の半分(ナイキスト周波数)までを対象とする
        fmax = self.frequency / 2
        melmax = self.hz2mel(fmax)

        # 周波数に合わせて、サンプル数の半分の標本数で計算する
        nmax = self.nfft / 2
        df = self.frequency / self.nfft

        # フィルタごとの中心となるメル尺度を計算する
        dmel = melmax / (self.channels + 1)
        melcenters = numpy.arange(1, self.channels + 1) * dmel
        fcenters = self.mel2hz(melcenters)

        # それぞれの標本が対象とする周波数の範囲を計算する
        indexcenter = numpy.round(fcenters / df)
        indexstart = numpy.hstack(([0], indexcenter[0: self.channels - 1]))
        indexstop = numpy.hstack((indexcenter[1: self.channels], [nmax]))

        # フィルタごとにindexstartを始点、indexcenterを頂点、
        # indexstopを終点とする三角形のグラフを描くように計算する
        filterbank = numpy.zeros((self.channels, nmax))
        for c in numpy.arange(0, self.channels):
            increment = 1.0 / (indexcenter[c] - indexstart[c])
            for i in numpy.arange(indexstart[c], indexcenter[c]):
                filterbank[c, i] = (i - indexstart[c]) * increment
            decrement = 1.0 / (indexstop[c] - indexcenter[c])
            for i in numpy.arange(indexcenter[c], indexstop[c]):
                filterbank[c, i] = 1.0 - ((i - indexcenter[c]) * decrement)
            filterbank[c] /= (indexstop[c] - indexstart[c]) / 2

        return filterbank, fcenters
</pre></list>
<p>ここで、self.channelsはメルフィルタバンクに用いられるバンドパスフィルタの数を示しており、後に出てくるMFCCの次元数と同じか、より大きくする必要がある。</p>
<p>このメルフィルタバンクをスペクトル包絡に適用した後に、離散コサイン変換によって得られる係数がMFCCである。つまり、MFCCを得る関数は以下のようになる。</p>
<list type='emlist'><caption aid:pstyle='emlist-title'>MFCCの導出</caption>
<pre>    def mfcc(self, spectrum):
        # スペクトル包絡として負の値が与えられた場合は、0として扱う
        spectrum = numpy.maximum(numpy.zeros(spectrum.shape), spectrum)
        # スペクトル包絡とメルフィルタバンクの積の対数を取る
        mspectrum = numpy.log10(numpy.dot(spectrum, self.filterbank.transpose()))
        # scipyを用いて離散コサイン変換をする
        return scipy.fftpack.dct(mspectrum, norm = 'ortho')[:self.dimension]
</pre></list>
<p>ここで、self.dimensionは離散コサイン変換の結果のうち低次の係数から何次元だけ用いるかを示しており、一般には16次元の係数を用いることが多いが、より精度を求める場合には32次元や64次元と設定することもある。</p>
<p>また、MFCCからスペクトル包絡への逆変換は、離散コサイン変換の逆変換を用いて、以下のように実装できる。この実装においては、逆変換の後にscipy.interpolateを用いてスプライン補間をしている。</p>
<list type='emlist'><caption aid:pstyle='emlist-title'>MFCCからのスペクトル包絡の導出</caption>
<pre>    def imfcc(self, mfcc):
        # MFCCの削られた部分に0を代入した上で、逆離散コサイン変換をする
        mfcc = numpy.hstack([mfcc, [0] * (self.channels - self.dimension)])
        mspectrum = scipy.fftpack.idct(mfcc, norm = 'ortho')
        # 得られた離散的な値をスプライン補間によって連続的にする
        tck = scipy.interpolate.splrep(self.fcenters, numpy.power(10, mspectrum))
        return scipy.interpolate.splev(self.fscale, tck)
</pre></list>
<p>そして、今後のために動的変化量を求める関数を実装しておく。これは、あるフレームの前後数フレームでのMFCCの変化量を微分したもの(回帰係数)であり、ここでは簡単のため、1つ前のフレームと1つ後のフレームの差を2で割ったものを用いることとする。</p>
<list type='emlist'><caption aid:pstyle='emlist-title'>MFCCの動的変化量の導出</caption>
<pre>    def delta(self, mfcc):
        # データの開始部と終了部は同じデータが続いているものとする
        mfcc = numpy.concatenate([[mfcc[0]], mfcc, [mfcc[-1]]])

        delta = None
        for i in xrange(1, mfcc.shape[0] - 1):
            # 前後のフレームの差を2で割ったものを動的変化量とする
            slope = (mfcc[i + 1] - mfcc[i - 1]) / 2
            if delta is None:
                delta = slope
            else:
                delta = numpy.vstack([delta, slope])

        return delta
</pre></list>
<p>これまでのソースコードを全部組み合わせたmfcc.pyは以下の通りである。なお、このモジュールをコマンドライン引数にSTFファイルを与えて実行すると、MFCCの出力及び元データとMFCCからの逆変換で得られるデータの波形の違いを確認することができる。</p>
<codelist>
<caption>リスト3.2　mfcc.py</caption>
<pre><span type='lineno'> 1: </span>#!/usr/bin/env python
<span type='lineno'> 2: </span>
<span type='lineno'> 3: </span>import numpy
<span type='lineno'> 4: </span>import scipy.fftpack
<span type='lineno'> 5: </span>import scipy.interpolate
<span type='lineno'> 6: </span>import scipy.linalg
<span type='lineno'> 7: </span>import sys
<span type='lineno'> 8: </span>
<span type='lineno'> 9: </span>from stf import STF
<span type='lineno'>10: </span>
<span type='lineno'>11: </span>class MFCC:
<span type='lineno'>12: </span>    '''
<span type='lineno'>13: </span>    MFCC computation from spectrum information
<span type='lineno'>14: </span>
<span type='lineno'>15: </span>    Reference
<span type='lineno'>16: </span>    ---------
<span type='lineno'>17: </span>     - http://aidiary.hatenablog.com/entry/20120225/1330179868
<span type='lineno'>18: </span>    '''
<span type='lineno'>19: </span>
<span type='lineno'>20: </span>    def __init__(self, nfft, frequency, dimension = 16, channels = 20):
<span type='lineno'>21: </span>        self.nfft = nfft
<span type='lineno'>22: </span>        self.frequency = frequency
<span type='lineno'>23: </span>        self.dimension = dimension
<span type='lineno'>24: </span>        self.channels = channels
<span type='lineno'>25: </span>
<span type='lineno'>26: </span>        self.fscale = \
<span type='lineno'>27: </span>            numpy.fft.fftfreq(self.nfft, d = 1.0 / self.frequency)[: self.nfft / 2]
<span type='lineno'>28: </span>        self.filterbank, self.fcenters = self.melFilterBank()
<span type='lineno'>29: </span>
<span type='lineno'>30: </span>    def hz2mel(self, f):
<span type='lineno'>31: </span>        return 1127.01048 * numpy.log(f / 700.0 + 1.0)
<span type='lineno'>32: </span>
<span type='lineno'>33: </span>    def mel2hz(self, m):
<span type='lineno'>34: </span>        return 700.0 * (numpy.exp(m / 1127.01048) - 1.0)
<span type='lineno'>35: </span>
<span type='lineno'>36: </span>    def melFilterBank(self):
<span type='lineno'>37: </span>        &lt;省略&gt;
<span type='lineno'>38: </span>
<span type='lineno'>39: </span>    def mfcc(self, spectrum):
<span type='lineno'>40: </span>        &lt;省略&gt;
<span type='lineno'>41: </span>
<span type='lineno'>42: </span>    def delta(self, mfcc):
<span type='lineno'>43: </span>        &lt;省略&gt;
<span type='lineno'>44: </span>
<span type='lineno'>45: </span>    def imfcc(self, mfcc):
<span type='lineno'>46: </span>        &lt;省略&gt;
<span type='lineno'>47: </span>
<span type='lineno'>48: </span>if __name__ == '__main__':
<span type='lineno'>49: </span>    if len(sys.argv) &lt; 2:
<span type='lineno'>50: </span>        print 'Usage: %s &lt;stf_file&gt;' % sys.argv[0]
<span type='lineno'>51: </span>        sys.exit()
<span type='lineno'>52: </span>
<span type='lineno'>53: </span>    stf = STF()
<span type='lineno'>54: </span>    stf.loadfile(sys.argv[1])
<span type='lineno'>55: </span>
<span type='lineno'>56: </span>    mfcc = MFCC(stf.SPEC.shape[1] * 2, stf.frequency)
<span type='lineno'>57: </span>    res = mfcc.mfcc(stf.SPEC[stf.SPEC.shape[0] / 5])
<span type='lineno'>58: </span>    spec = mfcc.imfcc(res)
<span type='lineno'>59: </span>
<span type='lineno'>60: </span>    print res
<span type='lineno'>61: </span>
<span type='lineno'>62: </span>    import pylab
<span type='lineno'>63: </span>
<span type='lineno'>64: </span>    pylab.subplot(211)
<span type='lineno'>65: </span>    pylab.plot(stf.SPEC[stf.SPEC.shape[0] / 5])
<span type='lineno'>66: </span>    pylab.ylim(0, 1.2)
<span type='lineno'>67: </span>    pylab.subplot(212)
<span type='lineno'>68: </span>    pylab.plot(spec)
<span type='lineno'>69: </span>    pylab.ylim(0, 1.2)
<span type='lineno'>70: </span>    pylab.show()
</pre></codelist>
<p>以下は、同じ音声データをMFCCに変換し、逆変換した結果を、16次元まで求めたものと、64次元まで求めたもので比べたものである。16次元でも低周波数ではある程度復元できているものの、64次元の方がより元のスペクトル包絡に近くなっていることがわかる。また、64次元のものでも、高周波数帯になるにつれて線が滑らかになってしまっているのがわかるだろう。</p>
<img>
<Image href="file://images/mfcc.png" scale="0.25" />
<caption>図3.1　MFCCの次元数による精度の違い</caption>
</img>
<title aid:pstyle="h2">3.3　動的時間伸縮の実装</title><?dtp level="2" section="3.3　動的時間伸縮の実装"?>
<p>GMMを使った学習処理を行う前に、もう1つ実装しておくべき機能が、動的時間伸縮(Dynamic Time Warping、以下、「DTW」という)である。これは、学習に使うパラレルデータを作るために欠かせない処理であり、同じ発話内容の音声データであっても話すスピードや間の長さの違いによってフレームごとでは対応が取れていない場合が多いので、DPマッチングに基づいてデータを伸縮させるという処理である。つまり、以下の図のように、同じ音を発している部分の対応を見つけ、両方が同じフレーム数になるように伸縮させるという処理である。</p>
<img>
<Image href="file://images/diff-spec.png" scale="0.25" />
<caption>図3.2　話者による波形の違い(<span type='bibref' idref='dtw-ut'>[5]</span>より引用)</caption>
</img>
<p>そのためには、まずDPマッチングを実装する必要がある。DPマッチングは、その名の通り動的計画法を用いた手法で、以下のように説明できる。</p>
<ol>
<li aid:pstyle="ol-item" olnum="1" num="1">1つ目のデータを<replace idref="texinline-1"><pre>a_1, a_2, ..., a_N</pre></replace>、2つ目のデータを<replace idref="texinline-2"><pre>b_1, b_2, ..., b_M</pre></replace>として、N×Mのグリッドグラフを用意する。</li>
<li aid:pstyle="ol-item" olnum="2" num="2">頂点<replace idref="texinline-3"><pre>(i, j)</pre></replace>に対し、<replace idref="texinline-4"><pre>a_i</pre></replace>と<replace idref="texinline-5"><pre>b_j</pre></replace>の類似度をコストとして設定する。</li>
<li aid:pstyle="ol-item" olnum="3" num="3">頂点<replace idref="texinline-6"><pre>(1, 1)</pre></replace>から頂点<replace idref="texinline-7"><pre>(N, M)</pre></replace>への最小コストのパスを検索する。</li>
<li aid:pstyle="ol-item" olnum="4" num="4">最小コストの値からパスを逆順に求めていき、頂点<replace idref="texinline-8"><pre>(i, j)</pre></replace>を通過したならば、<replace idref="texinline-9"><pre>a_i</pre></replace>と<replace idref="texinline-10"><pre>b_j</pre></replace>が対応していることがわかる。</li>
</ol>
<p>図で表すと以下の様なイメージとなる。同じ内容の発話をしているフレームに対応する頂点を、赤いパスが通過していることがわかる。</p>
<img>
<Image href="file://images/dtw-graph.png" scale="0.4" />
<caption>図3.3　DPマッチングのイメージ(<span type='bibref' idref='dtw-ut'>[5]</span>より引用)</caption>
</img>
<p>Pythonでの実装は以下の通りとなる。なお、self.distanceはフレーム間の類似度を算出する関数である。</p>
<list type='emlist'><caption aid:pstyle='emlist-title'>DPマッチング</caption>
<pre>    def dtw(self):
        M, N = len(self.source), len(self.target)
        cost = sys.maxint * numpy.ones((M, N))

        # グリッドグラフの1行目、1列目だけ先に処理しておく
        cost[0, 0] = self.distance(self.source[0], self.target[0])
        for i in range(1, M):
            cost[i, 0] = cost[i - 1, 0] + self.distance(self.source[i], self.target[0])
        for i in range(1, N):
            cost[0, i] = cost[0, i - 1] + self.distance(self.source[0], self.target[i])

        # 各頂点までの最短パスの長さを計算する
        for i in range(1, M):
            # 各フレームの前後self.windowフレームだけを参照する
            for j in range(max(1, i - self.window), min(N, i + self.window)):
                cost[i, j] = \
                        min(cost[i - 1, j - 1], cost[i, j - 1], cost[i - 1, j]) + \
                        self.distance(self.source[i], self.target[j])

        m, n = M - 1, N - 1
        self.path = []

        # 最短パスの経路を逆順に求めていく
        while (m, n) != (0, 0):
            self.path.append((m, n))
            m, n = min((m - 1, n), (m, n - 1), (m - 1, n - 1), \
                                    key = lambda x: cost[x[0], x[1]])
            if m &lt; 0 or n &lt; 0:
                break

        self.path.append((0, 0))
</pre></list>
<p>ここで注意すべき点は、self.windowによる探索範囲の制限である。これは、あるフレームに対して比較対象を前後self.windowフレームのみに限定するというもので、探索時間と、同じ発話内容が繰り返し現れた時に異なる繰り返しを参照してしまう可能性の低減を目的としている。これまで使ってみた限りでは、self.windowを2つのデータのフレーム数の差の2倍程度にちょうど設定するくらいがよいであろう。</p>
<p>次に、DPマッチングの結果に応じてデータを伸縮させる処理を実装する。この際、単に対応するフレームを用いるのではなく、1つ前のフレームが対応するフレームとの間で最も類似度が高いものを選ぶようにしている。つまり、DPマッチングの説明の時と同じ記号を用いると、パスが<replace idref="texinline-11"><pre>(i, j)</pre></replace>の次に<replace idref="texinline-12"><pre>(i + 1, k)</pre></replace>を通るとすると、<replace idref="texinline-13"><pre>a_{i+1}</pre></replace>に対応するフレームは、<replace idref="texinline-14"><pre>b_j, b_{j+1}, ..., b_k</pre></replace>の中で最も<replace idref="texinline-15"><pre>a_{i+1}</pre></replace>に類似度が高いフレームを選ぶ。</p>
<list type='emlist'><caption aid:pstyle='emlist-title'>DPマッチングによる伸縮</caption>
<pre>    def align(self, data, reverse = False):
        # reverse = Trueの時は、targetのフレーム数に合わせるようにする
        if reverse:
            path = [(t[1], t[0]) for t in self.path]
            source = self.target
            target = self.source
        else:
            path = self.path
            source = self.source
            target = self.target

        path.sort(key = lambda x: (x[1], x[0]))

        shape = tuple([path[-1][1] + 1] + list(data.shape[1:]))
        alignment = numpy.ndarray(shape)

        idx = 0
        frame = 0
        candicates = []

        while idx &lt; len(path) and frame &lt; target.shape[0]:
            if path[idx][1] &gt; frame:
                # 候補となっているフレームから最も類似度が高いフレームを選ぶ
                candicates.sort(key = lambda x: \
                                    self.distance(source[x], target[frame]))
                alignment[frame] = data[candicates[0]]

                candicates = [path[idx][0]]
                frame += 1
            else:
                candicates.append(path[idx][0])
                idx += 1

        if frame &lt; target.shape[0]:
            candicates.sort(key = lambda x: self.distance(source[x], target[frame]))
            alignment[frame] = data[candicates[0]]

        return alignment
</pre></list>
<p>DTWの実装をすべてまとめてモジュールとしたものが以下のソースコードである。この実装では、ユークリッド距離とコサイン距離のどちらかから類似度計算関数を選択できるようにしている。また、このモジュールをコマンドライン引数に2つのSTFファイルを与えて実行すると、DTW前と後での2つのMFCCの第1次係数のズレの違いが確認できるようになっている。</p>
<codelist>
<caption>リスト3.3　dtw.py</caption>
<pre><span type='lineno'> 1: </span>#!/usr/bin/env python
<span type='lineno'> 2: </span>
<span type='lineno'> 3: </span>import numpy
<span type='lineno'> 4: </span>import scipy
<span type='lineno'> 5: </span>import scipy.linalg
<span type='lineno'> 6: </span>import sys
<span type='lineno'> 7: </span>
<span type='lineno'> 8: </span>class DTW:
<span type='lineno'> 9: </span>    def __getstate__(self):
<span type='lineno'>10: </span>        d = self.__dict__.copy()
<span type='lineno'>11: </span>
<span type='lineno'>12: </span>        if self.distance == self.cosine:
<span type='lineno'>13: </span>            d['distance'] = 'cosine'
<span type='lineno'>14: </span>        elif self.distance == self.euclidean:
<span type='lineno'>15: </span>            d['distance'] = 'euclidean'
<span type='lineno'>16: </span>
<span type='lineno'>17: </span>        return d
<span type='lineno'>18: </span>
<span type='lineno'>19: </span>    def __setstate__(self, dict):
<span type='lineno'>20: </span>        self.__dict__ = dict
<span type='lineno'>21: </span>
<span type='lineno'>22: </span>        if dict['distance'] == 'cosine':
<span type='lineno'>23: </span>            self.distance = self.cosine
<span type='lineno'>24: </span>        elif dict['distance'] == 'euclidean':
<span type='lineno'>25: </span>            self.distance = self.euclidean
<span type='lineno'>26: </span>
<span type='lineno'>27: </span>    def cosine(self, A, B):
<span type='lineno'>28: </span>        return scipy.dot(A, B.transpose()) / scipy.linalg.norm(A) \
<span type='lineno'>29: </span>                                                / scipy.linalg.norm(B)
<span type='lineno'>30: </span>
<span type='lineno'>31: </span>    def euclidean(self, A, B):
<span type='lineno'>32: </span>        return scipy.linalg.norm(A - B)
<span type='lineno'>33: </span>
<span type='lineno'>34: </span>    def __init__(self, source, target, distance = None, window = sys.maxint):
<span type='lineno'>35: </span>        self.window = window
<span type='lineno'>36: </span>        self.source = source
<span type='lineno'>37: </span>        self.target = target
<span type='lineno'>38: </span>
<span type='lineno'>39: </span>        if distance:
<span type='lineno'>40: </span>            self.distance = distance
<span type='lineno'>41: </span>        else:
<span type='lineno'>42: </span>            self.distance = self.euclidean
<span type='lineno'>43: </span>
<span type='lineno'>44: </span>        self.dtw()
<span type='lineno'>45: </span>
<span type='lineno'>46: </span>    def dtw(self):
<span type='lineno'>47: </span>        &lt;省略&gt;
<span type='lineno'>48: </span>
<span type='lineno'>49: </span>    def align(self, data, reverse = False):
<span type='lineno'>50: </span>        &lt;省略&gt;
<span type='lineno'>51: </span>
<span type='lineno'>52: </span>if __name__ == '__main__':
<span type='lineno'>53: </span>    if len(sys.argv) &lt; 3:
<span type='lineno'>54: </span>        print 'Usage: %s &lt;source stf&gt; &lt;target stf&gt;' % sys.argv[0]
<span type='lineno'>55: </span>        sys.exit()
<span type='lineno'>56: </span>
<span type='lineno'>57: </span>    from stf import STF
<span type='lineno'>58: </span>    source, target = STF(), STF()
<span type='lineno'>59: </span>    source.loadfile(sys.argv[1])
<span type='lineno'>60: </span>    target.loadfile(sys.argv[2])
<span type='lineno'>61: </span>
<span type='lineno'>62: </span>    from mfcc import MFCC
<span type='lineno'>63: </span>    mfcc = MFCC(source.SPEC.shape[1] * 2, source.frequency)
<span type='lineno'>64: </span>    source_mfcc = numpy.array([mfcc.mfcc(source.SPEC[frame]) \
<span type='lineno'>65: </span>                        for frame in xrange(source.SPEC.shape[0])])
<span type='lineno'>66: </span>    mfcc = MFCC(target.SPEC.shape[1] * 2, target.frequency)
<span type='lineno'>67: </span>    target_mfcc = numpy.array([mfcc.mfcc(target.SPEC[frame]) \
<span type='lineno'>68: </span>                        for frame in xrange(target.SPEC.shape[0])])
<span type='lineno'>69: </span>
<span type='lineno'>70: </span>    dtw = DTW(source_mfcc, target_mfcc, \
<span type='lineno'>71: </span>        window = abs(source_mfcc.shape[0] - target_mfcc.shape[0]) * 2)
<span type='lineno'>72: </span>    warp_mfcc = dtw.align(source_mfcc)
<span type='lineno'>73: </span>
<span type='lineno'>74: </span>    import pylab
<span type='lineno'>75: </span>    pylab.subplot(211)
<span type='lineno'>76: </span>    pylab.plot(source_mfcc[:, 0])
<span type='lineno'>77: </span>    pylab.plot(target_mfcc[:, 0])
<span type='lineno'>78: </span>    pylab.subplot(212)
<span type='lineno'>79: </span>    pylab.plot(warp_mfcc[:, 0])
<span type='lineno'>80: </span>    pylab.plot(target_mfcc[:, 0])
<span type='lineno'>81: </span>    pylab.show()
</pre></codelist>
<p>このモジュールを同じ発話内容を異なる話者が発声したデータを使って実行した結果である。上のグラフだと、最初から大きくずれが発生し、終了位置も異なるが、下のグラフだと、波形がマッチしており、長さも等しくなっていることが分かる。</p>
<img>
<Image href="file://images/dtw-result.png" />
<caption>図3.4　DTWの実行結果</caption>
</img>
</doc>
